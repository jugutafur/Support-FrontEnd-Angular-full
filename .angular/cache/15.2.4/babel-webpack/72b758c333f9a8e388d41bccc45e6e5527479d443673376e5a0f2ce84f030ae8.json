{"ast":null,"code":"import * as i0 from \"@angular/core\";\nexport class JaxbComponent {\n  constructor() {\n    this.abrellave = \"{\";\n    this.cierrallave = \"}\";\n    this.abreDiamante = \"<\";\n    this.cierraDiamante = \">\";\n    this.abreParentesis = \"(\";\n    this.cierraParentesis = \")\";\n    this.abreCuadro = \"[\";\n    this.cierraCuadro = \"]\";\n  }\n}\nJaxbComponent.ɵfac = function JaxbComponent_Factory(t) {\n  return new (t || JaxbComponent)();\n};\nJaxbComponent.ɵcmp = /*@__PURE__*/i0.ɵɵdefineComponent({\n  type: JaxbComponent,\n  selectors: [[\"app-jaxb\"]],\n  decls: 222,\n  vars: 6,\n  consts: [[1, \"container\"], [1, \"table\", \"table-striped\", \"table-hover\", \"table-bordered\", \"align-middle\"], [\"scope\", \"col\"], [\"href\", \"https://www.vogella.com/tutorials/JAXB/article.html\"], [\"src\", \"../../../../../assets/framework/Jaxb/ContextMarshaller.png\", \"alt\", \"ContextMarshaller\", \"title\", \"ContextMarshaller\"], [\"href\", \"https://programmerclick.com/article/6698169995/\"], [\"src\", \"../../../../../assets/framework/Jaxb/Anotaciones.png\", \"alt\", \"Anotaciones\", \"title\", \"Anotaciones\"], [\"src\", \"../../../../../assets/framework/Jaxb/XmlAdapter.png\", \"alt\", \"XmlAdapter\", \"title\", \"XmlAdapter\"]],\n  template: function JaxbComponent_Template(rf, ctx) {\n    if (rf & 1) {\n      i0.ɵɵelementStart(0, \"div\", 0)(1, \"table\", 1)(2, \"thead\")(3, \"tr\")(4, \"th\", 2);\n      i0.ɵɵtext(5, \"Referencia\");\n      i0.ɵɵelementEnd();\n      i0.ɵɵelementStart(6, \"th\", 2);\n      i0.ɵɵtext(7, \"Descripcion\");\n      i0.ɵɵelementEnd();\n      i0.ɵɵelementStart(8, \"th\", 2);\n      i0.ɵɵtext(9, \"Ejemplo\");\n      i0.ɵɵelementEnd()()();\n      i0.ɵɵelementStart(10, \"tbody\")(11, \"tr\")(12, \"td\")(13, \"strong\");\n      i0.ɵɵtext(14, \"Jaxb \\\"jaz-binding\\\" pronunciacion\");\n      i0.ɵɵelementEnd()();\n      i0.ɵɵelementStart(15, \"td\")(16, \"a\", 3);\n      i0.ɵɵtext(17, \"Ver info\");\n      i0.ɵɵelementEnd();\n      i0.ɵɵelement(18, \"br\")(19, \"br\");\n      i0.ɵɵtext(20, \" Java JAXB o Java XML API Binding nos permite trabajar con XML y JSON de una forma c\\u00F3moda usando Java. Vamos a ver una introducci\\u00F3n a este est\\u00E1ndar y sus anotaciones \");\n      i0.ɵɵelement(21, \"br\")(22, \"br\");\n      i0.ɵɵtext(23, \" Con versiones de Java anteriores a Java 11, JAXB era parte de JVM y pod\\u00EDa usarlo directamente sin definir bibliotecas adicionales. \");\n      i0.ɵɵelement(24, \"br\")(25, \"br\");\n      i0.ɵɵtext(26, \" A partir de Java 11, JAXB ya no forma parte de JRE y debe configurar las bibliotecas relevantes a trav\\u00E9s de su sistema de gesti\\u00F3n de dependencias, por ejemplo, Maven o Gradle \");\n      i0.ɵɵelementEnd();\n      i0.ɵɵelementStart(27, \"td\");\n      i0.ɵɵelement(28, \"img\", 4)(29, \"br\")(30, \"br\");\n      i0.ɵɵelementEnd()();\n      i0.ɵɵelementStart(31, \"tr\")(32, \"td\")(33, \"a\", 5);\n      i0.ɵɵtext(34, \"Anotaciones \");\n      i0.ɵɵelementEnd()();\n      i0.ɵɵelementStart(35, \"td\")(36, \"strong\");\n      i0.ɵɵtext(37, \"@XmlRootElement(namespace = \\\"namespace\\\")\");\n      i0.ɵɵelementEnd();\n      i0.ɵɵtext(38, \" que especifica la clase raiz que vamos a convertir a XML. \");\n      i0.ɵɵelement(39, \"br\")(40, \"br\");\n      i0.ɵɵelementStart(41, \"strong\");\n      i0.ɵɵtext(42, \"@XmlElement(name = \\\"neuName\\\")\");\n      i0.ɵɵelementEnd();\n      i0.ɵɵtext(43, \" permite cambiar el nombre de los elementos cuando el fichero XML se construya \");\n      i0.ɵɵelement(44, \"br\")(45, \"br\");\n      i0.ɵɵelementStart(46, \"strong\");\n      i0.ɵɵtext(47);\n      i0.ɵɵelementEnd();\n      i0.ɵɵtext(48, \"Permite definir el orden en que se escriben los campos en el archivo XML \");\n      i0.ɵɵelement(49, \"br\")(50, \"br\");\n      i0.ɵɵelementStart(51, \"strong\");\n      i0.ɵɵtext(52, \"@XmlEnum\");\n      i0.ɵɵelementEnd();\n      i0.ɵɵtext(53, \" Asigna un tipo de enumeraci\\u00F3n Enum a la representaci\\u00F3n XML. \");\n      i0.ɵɵelement(54, \"br\")(55, \"br\");\n      i0.ɵɵelementStart(56, \"strong\");\n      i0.ɵɵtext(57, \" @XmlEnumValue \");\n      i0.ɵɵelementEnd();\n      i0.ɵɵtext(58, \"Asigna una constante de enumeraci\\u00F3n \");\n      i0.ɵɵelementStart(59, \"strong\");\n      i0.ɵɵtext(60, \"Enum\");\n      i0.ɵɵelementEnd();\n      i0.ɵɵtext(61, \" en Enumtipo a la representaci\\u00F3n XML. \");\n      i0.ɵɵelement(62, \"br\")(63, \"br\");\n      i0.ɵɵelementStart(64, \"strong\");\n      i0.ɵɵtext(65, \"@XmlAnyElement\");\n      i0.ɵɵelementEnd();\n      i0.ɵɵtext(66, \" Asigna una propiedad JavaBean a una representaci\\u00F3n de conjunto de informaci\\u00F3n XML y/o un elemento JAXB. \");\n      i0.ɵɵelement(67, \"br\")(68, \"br\");\n      i0.ɵɵtext(69, \" Esta anotaci\\u00F3n sirve como una propiedad \\\"catch-all\\\" mientras desorganiza el contenido xml en una instancia de una clase anotada JAXB. Por lo general, anota una propiedad JavaBean de varios valores, pero puede ocurrir en una propiedad JavaBean de un solo valor. Durante la desclasificaci\\u00F3n, cada elemento xml que no coincide con una anotaci\\u00F3n est\\u00E1tica @XmlElement o @XmlElementRef para las otras propiedades de JavaBean en la clase, se agrega a esta propiedad \\\"catch-all\\\". \");\n      i0.ɵɵelement(70, \"br\")(71, \"br\");\n      i0.ɵɵelementStart(72, \"strong\");\n      i0.ɵɵtext(73, \"@XmlAccessorType \");\n      i0.ɵɵelementEnd();\n      i0.ɵɵtext(74, \"Controla si los campos o las propiedades de Javabean se serializan de forma predeterminada. Esta anotaci\\u00F3n se puede utilizar con los siguientes elementos del programa: \");\n      i0.ɵɵelementStart(75, \"strong\");\n      i0.ɵɵtext(76, \"PROPERTY, FIEL, PUBLIC_MEMBER, NONE = a nivel de paquete o una clase de primer nivel\");\n      i0.ɵɵelementEnd();\n      i0.ɵɵelement(77, \"br\")(78, \"br\");\n      i0.ɵɵtext(79, \" Esta anotaci\\u00F3n proporciona control sobre la serializaci\\u00F3n predeterminada de propiedades y campos en una clase. \");\n      i0.ɵɵelement(80, \"br\");\n      i0.ɵɵtext(81, \"La anotaci\\u00F3n en un paquete se aplica a todas las clases del paquete. Se aplica la siguiente sem\\u00E1ntica de herencia: \");\n      i0.ɵɵelement(82, \"br\")(83, \"br\");\n      i0.ɵɵtext(84, \" * Si hay un @XmlAccessorType en una clase, entonces se usa. \");\n      i0.ɵɵelement(85, \"br\");\n      i0.ɵɵtext(86, \" * De lo contrario, si existe un @XmlAccessorType en una de sus superclases, se hereda. \");\n      i0.ɵɵelement(87, \"br\");\n      i0.ɵɵtext(88, \" * De lo contrario, se hereda el @XmlAccessorType en un paquete. \");\n      i0.ɵɵelement(89, \"br\");\n      i0.ɵɵelementEnd();\n      i0.ɵɵelementStart(90, \"td\");\n      i0.ɵɵelement(91, \"img\", 6)(92, \"br\")(93, \"br\");\n      i0.ɵɵelementEnd()();\n      i0.ɵɵelementStart(94, \"tr\")(95, \"td\")(96, \"strong\");\n      i0.ɵɵtext(97, \"contexto \");\n      i0.ɵɵelementEnd()();\n      i0.ɵɵelementStart(98, \"td\");\n      i0.ɵɵtext(99, \" El contexto se encarga de definir los objetos de negocio que vamos a utilizar \");\n      i0.ɵɵelementEnd();\n      i0.ɵɵelement(100, \"td\");\n      i0.ɵɵelementEnd();\n      i0.ɵɵelementStart(101, \"tr\")(102, \"td\")(103, \"strong\");\n      i0.ɵɵtext(104, \"marshaller\");\n      i0.ɵɵelementEnd()();\n      i0.ɵɵelementStart(105, \"td\");\n      i0.ɵɵtext(106, \" El marshaller en que forma vamos a generar la estructura \");\n      i0.ɵɵelementEnd();\n      i0.ɵɵelement(107, \"td\");\n      i0.ɵɵelementEnd();\n      i0.ɵɵelementStart(108, \"tr\")(109, \"td\")(110, \"strong\");\n      i0.ɵɵtext(111, \"@XmlType\");\n      i0.ɵɵelementEnd()();\n      i0.ɵɵelementStart(112, \"td\");\n      i0.ɵɵtext(113, \" se usa en anotaciones de clase, y a menudo se usa junto con @XmlRootElement, @XmlAccessorType. Tiene tres atributos: nombre, propOrder, espacio de nombres, y solo se usan a menudo los dos primeros atributos. Como: \");\n      i0.ɵɵelement(114, \"br\")(115, \"br\");\n      i0.ɵɵtext(116);\n      i0.ɵɵelementEnd();\n      i0.ɵɵelement(117, \"td\");\n      i0.ɵɵelementEnd();\n      i0.ɵɵelementStart(118, \"tr\")(119, \"td\")(120, \"strong\");\n      i0.ɵɵtext(121, \"@XmlElement\");\n      i0.ɵɵelementEnd()();\n      i0.ɵɵelementStart(122, \"td\");\n      i0.ɵɵtext(123, \" asigna los atributos de los objetos java a los nodos xml. Al usar @XmlElement, puede cambiar el nombre de los atributos de los objetos java que se muestran en xml a trav\\u00E9s del atributo name. Como: \");\n      i0.ɵɵelement(124, \"br\")(125, \"br\");\n      i0.ɵɵtext(126, \" @XmlElement(name=\\\"Address\\\") \");\n      i0.ɵɵelement(127, \"br\");\n      i0.ɵɵtext(128, \" private String yourAddress; \");\n      i0.ɵɵelementEnd();\n      i0.ɵɵelement(129, \"td\");\n      i0.ɵɵelementEnd();\n      i0.ɵɵelementStart(130, \"tr\")(131, \"td\")(132, \"strong\");\n      i0.ɵɵtext(133, \"@XmlRootElement\");\n      i0.ɵɵelementEnd()();\n      i0.ɵɵelementStart(134, \"td\");\n      i0.ɵɵtext(135, \" se usa para anotaciones de nivel de clase, correspondientes al elemento de seguimiento xml, que a menudo se usa con @XmlType y @XmlAccessorType. Como: \");\n      i0.ɵɵelement(136, \"br\")(137, \"br\");\n      i0.ɵɵtext(138, \" @XmlType \");\n      i0.ɵɵelement(139, \"br\");\n      i0.ɵɵtext(140, \" @XmlAccessorType(XmlAccessType.FIELD) \");\n      i0.ɵɵelement(141, \"br\");\n      i0.ɵɵtext(142, \" @XmlRootElement \");\n      i0.ɵɵelement(143, \"br\");\n      i0.ɵɵtext(144);\n      i0.ɵɵelement(145, \"br\");\n      i0.ɵɵelementEnd();\n      i0.ɵɵelement(146, \"td\");\n      i0.ɵɵelementEnd();\n      i0.ɵɵelementStart(147, \"tr\")(148, \"td\")(149, \"strong\");\n      i0.ɵɵtext(150, \"@XmlAccessorType\");\n      i0.ɵɵelementEnd()();\n      i0.ɵɵelementStart(151, \"td\");\n      i0.ɵɵtext(152, \" se utiliza para especificar el m\\u00E9todo de acceso de los atributos de objeto java al generar archivos xml a partir de objetos java. A menudo se usa con @XmlRootElement, @XmlType. Sus valores de atributo son 4 valores de enumeraci\\u00F3n de XmlAccessType, que se dividen en: \");\n      i0.ɵɵelement(153, \"br\")(154, \"br\");\n      i0.ɵɵelementStart(155, \"strong\");\n      i0.ɵɵtext(156, \"XmlAccessType.FIELD:\");\n      i0.ɵɵelementEnd();\n      i0.ɵɵtext(157, \" todas las variables miembro en el objeto java \");\n      i0.ɵɵelement(158, \"br\");\n      i0.ɵɵelementStart(159, \"strong\");\n      i0.ɵɵtext(160, \"XmlAccessType.PROPERTY:\");\n      i0.ɵɵelementEnd();\n      i0.ɵɵtext(161, \" todas las variables miembro en el objeto java al que accede getter / setter \");\n      i0.ɵɵelement(162, \"br\");\n      i0.ɵɵelementStart(163, \"strong\");\n      i0.ɵɵtext(164, \"XmlAccessType.PUBLIC_MEMBER:\");\n      i0.ɵɵelementEnd();\n      i0.ɵɵtext(165, \" todas las variables miembro de la autoridad de acceso p\\u00FAblico en el objeto java y las variables miembro a las que accede getter / setter \");\n      i0.ɵɵelement(166, \"br\");\n      i0.ɵɵelementStart(167, \"strong\");\n      i0.ɵɵtext(168, \"XmlAccessType.NONE:\");\n      i0.ɵɵelementEnd();\n      i0.ɵɵtext(169, \" todos los atributos del objeto java no est\\u00E1n asignados a elementos xml \");\n      i0.ɵɵelement(170, \"br\")(171, \"br\");\n      i0.ɵɵtext(172, \" Nota: El nivel de acceso predeterminado de @XmlAccessorType es XmlAccessType.PUBLIC_MEMBER, por lo tanto, si la variable miembro privado en el objeto java se establece con el m\\u00E9todo p\\u00FAblico getter / setter, no use las anotaciones @XmlElement y @XmlAttribute en la variable privada, de lo contrario Cuando el objeto java genera xml, informar\\u00E1 el error de que el mismo atributo existe dos veces en la clase java. Del mismo modo, si el permiso de acceso de @XmlAccessorType es XmlAccessType.NONE, si se usan las anotaciones @XmlElement o @XmlAttribute en las variables miembro de Java, estas variables miembro a\\u00FAn se pueden asignar al archivo xml. \");\n      i0.ɵɵelementEnd();\n      i0.ɵɵelement(173, \"td\");\n      i0.ɵɵelementEnd();\n      i0.ɵɵelementStart(174, \"tr\")(175, \"td\")(176, \"strong\");\n      i0.ɵɵtext(177, \"@XmlAccessorOrder\");\n      i0.ɵɵelementEnd()();\n      i0.ɵɵelementStart(178, \"td\");\n      i0.ɵɵtext(179, \" se usa para ordenar los elementos xml generados por los objetos java. Tiene dos valores de atributo: \");\n      i0.ɵɵelement(180, \"br\")(181, \"br\");\n      i0.ɵɵelementStart(182, \"strong\");\n      i0.ɵɵtext(183, \"AccessorOrder.ALPHABETICAL:\");\n      i0.ɵɵelementEnd();\n      i0.ɵɵtext(184, \" ordena los elementos xml generados en orden alfab\\u00E9tico \");\n      i0.ɵɵelement(185, \"br\");\n      i0.ɵɵelementStart(186, \"strong\");\n      i0.ɵɵtext(187, \"XmlAccessOrder.UNDEFINED:\");\n      i0.ɵɵelementEnd();\n      i0.ɵɵtext(188, \" no ordenar \");\n      i0.ɵɵelementEnd();\n      i0.ɵɵelement(189, \"td\");\n      i0.ɵɵelementEnd();\n      i0.ɵɵelementStart(190, \"tr\")(191, \"td\")(192, \"strong\");\n      i0.ɵɵtext(193, \"@XmlTransient\");\n      i0.ɵɵelementEnd()();\n      i0.ɵɵelementStart(194, \"td\");\n      i0.ɵɵtext(195, \" se utiliza para indicar que este atributo se ignora al mapear xml desde objetos java. Es decir, este elemento no aparece en el archivo xml generado. \");\n      i0.ɵɵelementEnd();\n      i0.ɵɵelement(196, \"td\");\n      i0.ɵɵelementEnd();\n      i0.ɵɵelementStart(197, \"tr\")(198, \"td\")(199, \"strong\");\n      i0.ɵɵtext(200, \"@XmlJavaTypeAdapter\");\n      i0.ɵɵelementEnd()();\n      i0.ɵɵelementStart(201, \"td\");\n      i0.ɵɵtext(202, \" se usa com\\u00FAnmente al convertir objetos m\\u00E1s complejos, como el tipo de mapa o la fecha de formato. Al usar esta anotaci\\u00F3n, debe escribir una clase de adaptador para heredar la clase abstracta XmlAdapter e implementar los m\\u00E9todos en su interior. \");\n      i0.ɵɵelement(203, \"br\")(204, \"br\");\n      i0.ɵɵtext(205, \" @XmlJavaTypeAdapter (valor = xxx.class), el valor es la clase de adaptador definida por usted XmlAdapter es el siguiente: \");\n      i0.ɵɵelementEnd();\n      i0.ɵɵelementStart(206, \"td\");\n      i0.ɵɵelement(207, \"img\", 7)(208, \"br\")(209, \"br\");\n      i0.ɵɵelementEnd()();\n      i0.ɵɵelementStart(210, \"tr\");\n      i0.ɵɵelement(211, \"td\")(212, \"td\")(213, \"td\");\n      i0.ɵɵelementEnd();\n      i0.ɵɵelementStart(214, \"tr\");\n      i0.ɵɵelement(215, \"td\")(216, \"td\")(217, \"td\");\n      i0.ɵɵelementEnd();\n      i0.ɵɵelementStart(218, \"tr\");\n      i0.ɵɵelement(219, \"td\")(220, \"td\")(221, \"td\");\n      i0.ɵɵelementEnd()()()();\n    }\n    if (rf & 2) {\n      i0.ɵɵadvance(47);\n      i0.ɵɵtextInterpolate2(\"@XmlType(propOrder = \", ctx.abrellave, \" \\\"field2\\\", \\\"field1\\\",.. \", ctx.cierrallave, \")\");\n      i0.ɵɵadvance(69);\n      i0.ɵɵtextInterpolate2(\" @XmlType(name = \\\"basicStruct\\\", propOrder = \", ctx.abrellave, \" \\\"intValue\\\", \\\"stringArray\\\", \\\"stringValue\\\" \", ctx.cierrallave, \" ) \");\n      i0.ɵɵadvance(28);\n      i0.ɵɵtextInterpolate2(\" public class Address \", ctx.abrellave, \"\", ctx.cierrallave, \" \");\n    }\n  },\n  styles: [\"\\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IiIsInNvdXJjZVJvb3QiOiIifQ== */\"]\n});","map":{"version":3,"mappings":"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","names":["JaxbComponent","constructor","abrellave","cierrallave","abreDiamante","cierraDiamante","abreParentesis","cierraParentesis","abreCuadro","cierraCuadro","selectors","decls","vars","consts","template","i0"],"sourceRoot":"","sources":["C:\\Users\\HP\\Desktop\\juanTafur\\jugutafur\\Support-FrontEnd-Angular-full\\src\\app\\core\\components\\framewoks\\jaxb\\jaxb.component.ts","C:\\Users\\HP\\Desktop\\juanTafur\\jugutafur\\Support-FrontEnd-Angular-full\\src\\app\\core\\components\\framewoks\\jaxb\\jaxb.component.html"],"sourcesContent":["import { Component } from '@angular/core';\n\n@Component({\n  selector: 'app-jaxb',\n  templateUrl: './jaxb.component.html',\n  styleUrls: ['./jaxb.component.scss']\n})\nexport class JaxbComponent {\n\n  public abrellave: string;\n  public cierrallave: string;\n  public abreDiamante: string;\n  public cierraDiamante: string;\n  public abreParentesis: string;\n  public cierraParentesis: string;\n  public abreCuadro: string;\n  public cierraCuadro: string;\n\n  constructor() {\n    this.abrellave= \"{\";\n    this.cierrallave=\"}\";\n    this.abreDiamante= \"<\";\n    this.cierraDiamante= \">\";\n    this.abreParentesis= \"(\";\n    this.cierraParentesis= \")\";\n    this.abreCuadro= \"[\";\n    this.cierraCuadro= \"]\";\n  }\n}\n","<div class=\"container\">\n  <table class=\"table table-striped table-hover table-bordered align-middle\">\n      <thead>\n          <tr>\n              <th scope=\"col\">Referencia</th>\n              <th scope=\"col\">Descripcion</th>\n              <th scope=\"col\">Ejemplo</th>\n          </tr>\n      </thead>\n      <tbody>\n          <tr>\n              <td><strong>Jaxb \"jaz-binding\" pronunciacion</strong></td>\n              <td>\n                <a href=\"https://www.vogella.com/tutorials/JAXB/article.html\">Ver info</a><br><br>\n                Java JAXB  o Java XML API Binding nos permite trabajar con XML y JSON de una forma cómoda usando Java.  Vamos a ver una introducción a este estándar y sus anotaciones <br><br>\n                Con versiones de Java anteriores a Java 11, JAXB era parte de JVM y podía usarlo directamente sin definir bibliotecas adicionales.\n                <br><br>\n                A partir de Java 11, JAXB ya no forma parte de JRE y debe configurar las bibliotecas relevantes a través de su sistema de gestión de dependencias, por ejemplo, Maven o Gradle\n              </td>\n              <td>\n                <img\n                src=\"../../../../../assets/framework/Jaxb/ContextMarshaller.png\"\n                alt=\"ContextMarshaller\"\n                title=\"ContextMarshaller\"><br><br>\n              </td>\n          </tr>\n\n          <tr>\n              <td><a href=\"https://programmerclick.com/article/6698169995/\">Anotaciones </a></td>\n              <td>\n                <strong>@XmlRootElement(namespace = \"namespace\")</strong> que especifica la clase raiz que vamos a convertir a XML. <br><br><strong>@XmlElement(name = \"neuName\")</strong> permite cambiar el nombre de los elementos cuando el fichero XML se construya <br><br>\n                <strong>@XmlType(propOrder = {{abrellave}} \"field2\", \"field1\",.. {{cierrallave}})</strong>Permite definir el orden en que se escriben los campos en el archivo XML <br><br>\n                <strong>@XmlEnum</strong> Asigna un tipo de enumeración Enum a la representación XML. <br><br>\n                <strong> @XmlEnumValue </strong>Asigna una constante de enumeración <strong>Enum</strong> en Enumtipo a la representación XML. <br><br>\n                <strong>@XmlAnyElement</strong> Asigna una propiedad JavaBean a una representación de conjunto de información XML y/o un elemento JAXB. <br><br>\n                Esta anotación sirve como una propiedad \"catch-all\" mientras desorganiza el contenido xml en una instancia de una clase anotada JAXB. Por lo general, anota una propiedad JavaBean de varios valores, pero puede ocurrir en una propiedad JavaBean de un solo valor. Durante la desclasificación, cada elemento xml que no coincide con una anotación estática @XmlElement o @XmlElementRef para las otras propiedades de JavaBean en la clase, se agrega a esta propiedad \"catch-all\". <br><br>\n                <strong>@XmlAccessorType </strong>Controla si los campos o las propiedades de Javabean se serializan de forma predeterminada. Esta anotación se puede utilizar con los siguientes elementos del programa: <strong>PROPERTY, FIEL, PUBLIC_MEMBER, NONE = a nivel de paquete o una clase de primer nivel</strong> <br><br>\n                Esta anotación proporciona control sobre la serialización predeterminada de propiedades y campos en una clase. <br>La anotación en un paquete se aplica a todas las clases del paquete. Se aplica la siguiente semántica de herencia:\n                <br><br>\n                * Si hay un @XmlAccessorType en una clase, entonces se usa. <br>\n                * De lo contrario, si existe un @XmlAccessorType en una de sus superclases, se hereda. <br>\n                * De lo contrario, se hereda el @XmlAccessorType en un paquete. <br>\n              </td>\n              <td>\n                <img\n                src=\"../../../../../assets/framework/Jaxb/Anotaciones.png\"\n                alt=\"Anotaciones\"\n                title=\"Anotaciones\"><br><br>\n              </td>\n          </tr>\n          <tr>\n              <td><strong>contexto </strong></td>\n              <td>\n                El contexto se encarga de definir los objetos de negocio que vamos a utilizar\n              </td>\n              <td></td>\n          </tr>\n\n          <tr>\n              <td><strong>marshaller</strong></td>\n              <td>\n                El marshaller en que forma vamos a generar la estructura\n              </td>\n              <td></td>\n          </tr>\n          <tr>\n              <td><strong>@XmlType</strong></td>\n              <td>\n                se usa en anotaciones de clase, y a menudo se usa junto con @XmlRootElement, @XmlAccessorType. Tiene tres atributos: nombre, propOrder, espacio de nombres, y solo se usan a menudo los dos primeros atributos. Como:\n                <br><br>\n                @XmlType(name = \"basicStruct\", propOrder = {{abrellave}}\n                \"intValue\",\n                \"stringArray\",\n                \"stringValue\" {{cierrallave}}\n                )\n              </td>\n              <td></td>\n          </tr>\n\n          <tr>\n              <td><strong>@XmlElement</strong></td>\n              <td>\n                asigna los atributos de los objetos java a los nodos xml. Al usar @XmlElement, puede cambiar el nombre de los atributos de los objetos java que se muestran en xml a través del atributo name. Como: <br><br>\n                @XmlElement(name=\"Address\") <br>\n                private String yourAddress;\n              </td>\n              <td></td>\n          </tr>\n          <tr>\n              <td><strong>@XmlRootElement</strong></td>\n              <td>\n                se usa para anotaciones de nivel de clase, correspondientes al elemento de seguimiento xml, que a menudo se usa con @XmlType y @XmlAccessorType. Como: <br><br>\n                @XmlType <br>\n                @XmlAccessorType(XmlAccessType.FIELD) <br>\n                @XmlRootElement <br>\n                public class Address {{abrellave}}{{cierrallave}} <br>\n              </td>\n              <td></td>\n          </tr>\n\n          <tr>\n              <td><strong>@XmlAccessorType</strong></td>\n              <td>\n                se utiliza para especificar el método de acceso de los atributos de objeto java al generar archivos xml a partir de objetos java. A menudo se usa con @XmlRootElement, @XmlType. Sus valores de atributo son 4 valores de enumeración de XmlAccessType, que se dividen en:\n                <br><br>\n                <strong>XmlAccessType.FIELD:</strong> todas las variables miembro en el objeto java\n                <br>\n                <strong>XmlAccessType.PROPERTY:</strong> todas las variables miembro en el objeto java al que accede getter / setter\n                <br>\n                <strong>XmlAccessType.PUBLIC_MEMBER:</strong> todas las variables miembro de la autoridad de acceso público en el objeto java y las variables miembro a las que accede getter / setter\n                <br>\n                <strong>XmlAccessType.NONE:</strong> todos los atributos del objeto java no están asignados a elementos xml <br><br>\n                Nota: El nivel de acceso predeterminado de @XmlAccessorType es XmlAccessType.PUBLIC_MEMBER, por lo tanto, si la variable miembro privado en el objeto java se establece con el método público getter / setter, no use las anotaciones @XmlElement y @XmlAttribute en la variable privada, de lo contrario Cuando el objeto java genera xml, informará el error de que el mismo atributo existe dos veces en la clase java. Del mismo modo, si el permiso de acceso de @XmlAccessorType es XmlAccessType.NONE, si se usan las anotaciones @XmlElement o @XmlAttribute en las variables miembro de Java, estas variables miembro aún se pueden asignar al archivo xml.\n              </td>\n              <td></td>\n          </tr>\n\n          <tr>\n              <td><strong>@XmlAccessorOrder</strong></td>\n              <td>\n                se usa para ordenar los elementos xml generados por los objetos java. Tiene dos valores de atributo:\n                <br><br>\n                <strong>AccessorOrder.ALPHABETICAL:</strong> ordena los elementos xml generados en orden alfabético <br>\n                <strong>XmlAccessOrder.UNDEFINED:</strong> no ordenar\n              </td>\n              <td></td>\n          </tr>\n\n          <tr>\n              <td><strong>@XmlTransient</strong></td>\n              <td>\n                se utiliza para indicar que este atributo se ignora al mapear xml desde objetos java. Es decir, este elemento no aparece en el archivo xml generado.\n              </td>\n              <td></td>\n          </tr>\n\n          <tr>\n              <td><strong>@XmlJavaTypeAdapter</strong></td>\n              <td>\n                se usa comúnmente al convertir objetos más complejos, como el tipo de mapa o la fecha de formato. Al usar esta anotación, debe escribir una clase de adaptador para heredar la clase abstracta XmlAdapter e implementar los métodos en su interior.\n                <br><br>\n                @XmlJavaTypeAdapter (valor = xxx.class), el valor es la clase de adaptador definida por usted\n\n                XmlAdapter es el siguiente:\n              </td>\n              <td>\n                <img\n                src=\"../../../../../assets/framework/Jaxb/XmlAdapter.png\"\n                alt=\"XmlAdapter\"\n                title=\"XmlAdapter\"><br><br>\n              </td>\n          </tr>\n\n          <tr>\n              <td></td>\n              <td></td>\n              <td></td>\n          </tr>\n          <tr>\n              <td></td>\n              <td></td>\n              <td></td>\n          </tr>\n\n          <tr>\n              <td></td>\n              <td></td>\n              <td></td>\n          </tr>\n      </tbody>\n  </table>\n</div>\n"]},"metadata":{},"sourceType":"module","externalDependencies":[]}